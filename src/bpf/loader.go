package bpf

import (
	"bytes"
	"encoding/binary"
	"errors"
	"fmt"
	"log"

	"github.com/cilium/ebpf/link"
	"github.com/cilium/ebpf/ringbuf"
	"github.com/cilium/ebpf/rlimit"
)

// EventCallback is a function that processes an event
type EventCallback func(eventType string, pid int, cid uint64, comm string, filename string)

func RunBPF(cb EventCallback) error {
	// Allow the current process to lock memory for eBPF resources.
	if err := rlimit.RemoveMemlock(); err != nil {
		return fmt.Errorf("removing memlock: %v", err)
	}

	// Load pre-compiled programs and maps into the kernel.
	objs := EventObjects{}
	if err := LoadEventObjects(&objs, nil); err != nil {
		return fmt.Errorf("loading objects: %v", err)
	}
	defer objs.Close()

	// Attach tracepoints
	kpExec, err := link.Tracepoint("syscalls", "sys_enter_execve", objs.TraceExecve, nil)
	if err != nil {
		return fmt.Errorf("linking trace_execve: %v", err)
	}
	defer kpExec.Close()

	kpOpen, err := link.Tracepoint("syscalls", "sys_enter_openat", objs.TraceOpenat, nil)
	if err != nil {
		return fmt.Errorf("linking trace_openat: %v", err)
	}
	defer kpOpen.Close()

	kpReadlink, err := link.Tracepoint("syscalls", "sys_enter_readlink", objs.TraceReadlink, nil)
	if err != nil {
		return fmt.Errorf("linking trace_readlink: %v", err)
	}
	defer kpReadlink.Close()

	kpReadlinkat, err := link.Tracepoint("syscalls", "sys_enter_readlinkat", objs.TraceReadlinkat, nil)
	if err != nil {
		return fmt.Errorf("linking trace_readlinkat: %v", err)
	}
	defer kpReadlinkat.Close()

	// Open a ringbuf reader from userspace RINGBUF map described in the
	// eBPF C program.
	rd, err := ringbuf.NewReader(objs.Events)
	if err != nil {
		return fmt.Errorf("opening ringbuf reader: %v", err)
	}
	defer rd.Close()

	log.Println("Waiting for events..")

	// bpfEventT is the Go struct matching the C struct event_t
	// It is generated by bpf2go
	var event EventEventT
	for {
		record, err := rd.Read()
		if err != nil {
			if errors.Is(err, ringbuf.ErrClosed) {
				log.Println("Received signal, exiting..")
				return nil
			}
			log.Printf("reading from reader: %v", err)
			continue
		}

		// Parse the ringbuf event entry into a bpfEvent structure.
		if err := binary.Read(bytes.NewBuffer(record.RawSample), binary.LittleEndian, &event); err != nil {
			log.Printf("parsing ringbuf event: %v", err)
			continue
		}

		eventType := "UNKNOWN"
		if event.Type == 1 {
			eventType = "EXECVE"
		} else if event.Type == 2 {
			eventType = "OPEN"
		} else if event.Type == 3 {
			eventType = "READLINK"
		}

		// Convert C strings to Go strings
		// We use Split to find the first null byte and take everything before it.
		// bytes.TrimRight is insufficient because the ringbuf memory is reused and may contain
		// garbage data after the first null terminator.
		comm := string(bytes.Split(event.Comm[:], []byte{0})[0])
		filename := string(bytes.Split(event.Filename[:], []byte{0})[0])

		cb(eventType, int(event.Pid), event.CgroupId, comm, filename)
	}
}
